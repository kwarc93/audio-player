

#include "ssd1306.h"

#include "gpio/gpio.h"
#include "misc.h"

#include "ascii_char.h"
#include "CalBlk36.h"
#include "CalLite24.h"

#include <stdint.h>
#include <stdbool.h>

/*
 * @brief GPIO definitions and routines for software SPI-Interface (hardware dependent)
 * Used ports: GPIOA, GPIOB, GPIOC, GPIOD
 */
#define SSD1306_VCC_PIN		(0)
#define SSD1306_VCC_PORT	(GPIOB)
#define SSD1306_VCC_LOW()	(SSD1306_VCC_PORT->BSRR = 1 << (SSD1306_VCC_PIN + 16))
#define SSD1306_VCC_HIGH()	(SSD1306_VCC_PORT->BSRR = 1 << SSD1306_VCC_PIN)

#define SSD1306_GND_PIN		(12)
#define SSD1306_GND_PORT	(GPIOB)
#define SSD1306_GND_LOW()	(SSD1306_GND_PORT->BSRR = 1 << (SSD1306_GND_PIN + 16))
#define SSD1306_GND_HIGH()	(SSD1306_GND_PORT->BSRR = 1 << SSD1306_GND_PIN)

#define SSD1306_CLK_PIN	 	(14)
#define SSD1306_CLK_PORT	(GPIOB)
#define SSD1306_CLK_LOW()	(SSD1306_CLK_PORT->BSRR = 1 << (SSD1306_CLK_PIN + 16))
#define SSD1306_CLK_HIGH()	(SSD1306_CLK_PORT->BSRR = 1 << SSD1306_CLK_PIN)

#define SSD1306_MOSI_PIN	(8)
#define SSD1306_MOSI_PORT	(GPIOD)
#define SSD1306_MOSI_LOW()	(SSD1306_MOSI_PORT->BSRR = 1 << (SSD1306_MOSI_PIN + 16))
#define SSD1306_MOSI_HIGH()	(SSD1306_MOSI_PORT->BSRR = 1 << SSD1306_MOSI_PIN)

#define SSD1306_CS_PIN	  	(10)
#define SSD1306_CS_PORT		(GPIOD)
#define SSD1306_CS_LOW()	(SSD1306_CS_PORT->BSRR = 1 << SSD1306_CS_PIN << 16)
#define SSD1306_CS_HIGH()	(SSD1306_CS_PORT->BSRR = 1 << SSD1306_CS_PIN)

#define SSD1306_DC_PIN	  	(12)
#define SSD1306_DC_PORT		(GPIOD)
#define SSD1306_DC_LOW()	(SSD1306_DC_PORT->BSRR = 1 << (SSD1306_DC_PIN + 16))
#define SSD1306_DC_HIGH()	(SSD1306_DC_PORT->BSRR = 1 << SSD1306_DC_PIN)

#define SSD1306_RST_PIN	 	(14)
#define SSD1306_RST_PORT	(GPIOD)
#define SSD1306_RST_LOW()	(SSD1306_RST_PORT->BSRR = 1 << (SSD1306_RST_PIN + 16))
#define SSD1306_RST_HIGH()	(SSD1306_RST_PORT->BSRR = 1 << SSD1306_RST_PIN)


static uint8_t     display_buffer[BUFFER];
static uint8_t     LCD_X=0;
static uint8_t     LCD_Y=0;
static uint8_t 	   byte;


static void softspi_init()
{
	/* Enable GPIO clocks */
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOBEN | RCC_AHB2ENR_GPIOCEN | RCC_AHB2ENR_GPIODEN;
	__DSB();

	// Supply pins
	GPIO_PinConfig(SSD1306_GND_PORT, SSD1306_GND_PIN, GPIO_OUT_PP_2MHz);
	SSD1306_GND_LOW();
	GPIO_PinConfig(SSD1306_VCC_PORT, SSD1306_VCC_PIN, GPIO_OUT_PP_2MHz);
	SSD1306_VCC_HIGH();

	// SPI interface pins
	GPIO_PinConfig(SSD1306_CLK_PORT,SSD1306_CLK_PIN,GPIO_OUT_PP_100MHz);
	GPIO_PinConfig(SSD1306_MOSI_PORT,SSD1306_MOSI_PIN,GPIO_OUT_PP_100MHz);
	GPIO_PinConfig(SSD1306_CS_PORT,SSD1306_CS_PIN,GPIO_OUT_PP_100MHz);
	GPIO_PinConfig(SSD1306_DC_PORT,SSD1306_DC_PIN,GPIO_OUT_PP_100MHz);
	GPIO_PinConfig(SSD1306_RST_PORT,SSD1306_RST_PIN,GPIO_OUT_PP_100MHz);

}

static inline void softspi_write_bit(uint8_t byte, uint8_t mask)
{
  SSD1306_CLK_LOW();
  if (byte & mask) SSD1306_MOSI_HIGH(); else SSD1306_MOSI_LOW();
  SSD1306_CLK_HIGH();
}


static void softspi_write_byte(uint8_t byte)
{
	/* transmit msb first, sample at clock falling edge */

	softspi_write_bit(byte, (1 << 7));
	softspi_write_bit(byte, (1 << 6));
	softspi_write_bit(byte, (1 << 5));
	softspi_write_bit(byte, (1 << 4));
	softspi_write_bit(byte, (1 << 3));
	softspi_write_bit(byte, (1 << 2));
	softspi_write_bit(byte, (1 << 1));
	softspi_write_bit(byte, (1 << 0));
}

static void set_instruction(_Bool dc, uint8_t byte)
{
	if(dc) 	SSD1306_DC_HIGH();
	else   	SSD1306_DC_LOW();

	SSD1306_CS_LOW();
	softspi_write_byte(byte);
	SSD1306_CS_HIGH();
	}

// These defaults are for a 128x64 configuration, adapt as needed
// seg remap, com scan, mux ratio, addr mode are suggested things to poke at
void SSD1306_Init() {

	softspi_init();
	delay_ms(10);

	SSD1306_RST_LOW();
	delay_ms(10);
	SSD1306_RST_HIGH();
	delay_ms(10);

	set_instruction(0, 0xAE); // display off
	set_instruction(0, 0xD5); // clock
	set_instruction(0, 0x81); // upper nibble is rate, lower nibble is divisor
	set_instruction(0, 0xA8); // mux ratio
	set_instruction(0, 0x3F); // rtfm
	set_instruction(0, 0xD3); // display offset
	set_instruction(0, 0x00); // rtfm
	set_instruction(0, 0x00);
	set_instruction(0, 0x8D); // charge pump
	set_instruction(0, 0x14); // enable
	set_instruction(0, 0x20); // memory addr mode
	set_instruction(0, 0x00); // horizontal
	set_instruction(0, 0xA1); // segment remap
	set_instruction(0, 0xA5); // display on
	set_instruction(0, 0xC8); // com scan direction
	set_instruction(0, 0xDA); // com hardware cfg
	set_instruction(0, 0x12); // alt com cfg
	set_instruction(0, 0x81); // contrast aka current
	set_instruction(0, 0x7F); // 128 is midpoint
	set_instruction(0, 0xD9); // precharge
	set_instruction(0, 0x11); // rtfm
	set_instruction(0, 0xDB); // vcomh deselect level
	set_instruction(0, 0x20); // rtfm
	set_instruction(0, 0xA6); // non-inverted
	set_instruction(0, 0xA4); // display scan on
	set_instruction(0, 0xAF); // drivers on

	clr_VRAM();

}

// Clear VRAM in LCD
void clr_VRAM()
{
	uint8_t height=64;
	uint8_t width=128;
	while(height--)
	{
		set_cursor(0,height);
		while(width--)
			set_instruction(1,0x00);
		width=lcd_width;
	}
}

// Set pixel on display buffer
void set_pixel(uint8_t x, uint8_t y) {
    display_buffer[((uint16_t)(y<<4)&0xFF80) + x] |= (uint8_t)(0x01 << (y & 0x07));
}

// Write byte on display buffer
void write_display(uint8_t data) {
    display_buffer[((uint16_t)(LCD_Y<<7)) + (LCD_X++)] |= data;
}

// Set cursor on display buffer
void set_cursor(uint8_t x, uint8_t y)
{
	LCD_X=x; LCD_Y=y;
}

// Clear display buffer
void clr_buff(void) {
    uint16_t i;
    for(i=0; i<BUFFER; i++) display_buffer[i]=0x00;
}

// Transfer display buffer to LCD
void show_buff(void) {
    unsigned char u8Page,u8Column;
    uint8_t *p;
    set_instruction(0,LCD_SET_PAGE);
    set_instruction(0,LCD_SET_COL_HI);	// Set column at 0
    set_instruction(0,LCD_SET_COL_LO);

    p=display_buffer;
   	// process the 8 pages of the LCD
	for(u8Page=0; u8Page<8; u8Page++) {
	    for(u8Column=0; u8Column<128; u8Column++) {
	    	set_instruction(1,*p++);
	    }
    }
}

// Cleans selected area of LCD
void clean_area(unsigned char x_start, unsigned char x_end, unsigned char y_start, unsigned char y_end)
{
	byte=x_start;
	while(y_start<=y_end)
	{
		set_cursor(x_start,y_start++);
		while(x_start++<=x_end)
			 write_display(0x00);
		x_start=byte;
	}
} 

// Sends bitmap directly to VRAM
void lcd_bitmap(const uint8_t *gData) {
    uint16_t i,j;
    for(j=0;j<8;j++) {
    	set_instruction(0,0xb0+j);   //set page address

    	set_instruction(0,0x10);     //set column Address
    	set_instruction(0,0x00);

        for(i=0;i<128;i++){
        	set_instruction(1,gData[i+(j*128)]);
        }

    }
}
// Draw a line
void lcd_line(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2) {
    uint8_t i,dxabs,dyabs,x,y;
    int8_t dx,dy,stepx,stepy;
    dx=(int8_t)x2-x1;      // the horizontal distance of the line
    dy=(int8_t)y2-y1;      // the vertical distance of the line
    if(dy<0) { dyabs=-dy; stepy=-1; }
    else { dyabs=dy; stepy=1; }
    if(dx<0) { dxabs=-dx; stepx=-1; }
    else {dxabs=dx; stepx=1; }
    x=(uint8_t)(dyabs>>1);
    y=(uint8_t)(dxabs>>1);
    set_pixel(x1,y1);
    if (dxabs>=dyabs) { // the line is more horizontal than vertical
        for(i=0;i<dxabs;i++) {
            y+=dyabs;
            if (y>=dxabs) {
                y-=dxabs;
                y1+=stepy;
            }
            x1+=stepx;
            set_pixel(x1,y1);
        }
    }
    else {  // the line is more vertical than horizontal
        for(i=0;i<dyabs;i++) {
            x+=dxabs;
            if (x>=dyabs) {
                x-=dyabs;
                x1+=stepx;
            }
            y1+=stepy;
            set_pixel(x1,y1);
        }
    }
}
/*------------------------------------------------ Small 5x8 font functions ------------------------------------------------------*/

void write_string(unsigned char x, unsigned char y, const  char *string)
{
	x*=(f_width+space_char);
	set_cursor(x,y);
	while(*string!=0)
	{
		send_data_array(ascii_table[*string++],f_width);
		y=space_char;	// space between chars
		while(y--) write_display(0);
	}
}

void write_char(unsigned char x, unsigned char y, unsigned char character)
{
	x*=(f_width+space_char);
	set_cursor(x,y);
	send_data_array(ascii_table[character],f_width);
}


void send_data_array(const char *d_array, unsigned char size)
{
	while(size--)
		 write_display(*(d_array++));
}
/*--------------------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------- Medium font functions --------------------------------------------------------*/
void lcdCharLite24(uint8_t x, uint8_t y, char s)
{
	uint8_t i;
	uint16_t size,idx;

	s-=32; // konwersja kodu znaku
	idx=0;
	size=4*(*(CalLite24_width + s));					// d³ugosæ znaku w tablicy
	set_cursor(x,y);

	for(i=0;i<s;i++) idx+=(*(CalLite24_width + i));	// obliczenie pozycji znaku w tablicy
	for(i = 0; i < size; i++)
		{
		if(i%(size/4)==0) set_cursor(x,y++);							// jesli osi¹gnelo szerokosæ znaku skocz do nowej linii
		 write_display((*(CalLite24 + 4*idx + i)));
		}

}

void lcdStringLite24(uint8_t x, uint8_t y, char * s)
{

	while(*s) // wykonuj dopóki znak wskazywany przez s jest ró¿ny od zera
	{
    lcdCharLite24(x,y,*s); // zapis znaku
	set_cursor(x+=(*(CalLite24_width + (*s++ - 32))) + 2,y); //przesuñ kursor o szerkokoæ znaku + 2pixele
	}

}
/*--------------------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------- Big font functions ----------------------------------------------------------*/
void lcdCharBlk36(uint8_t x, uint8_t y, char s)
{
	uint8_t i;
	uint16_t size,idx;

	s-=32; // konwersja kodu znaku
	idx=0;
	size=5*(*(CalBlk36_width + s));					// d³ugosæ znaku w tablicy
	set_cursor(x,y);

	for(i=0;i<s;i++) idx+=(*(CalBlk36_width + i));	// obliczenie pozycji znaku w tablicy
	for(i = 0; i < size; i++)
		{
		if(i%(size/5)==0) set_cursor(x,y++);							// jesli osi¹gnelo szerokosæ znaku skocz do nowej linii
		 write_display((*(CalBlk36 + 5*idx + i)));
		}

}

void lcdStringBlk36(uint8_t x, uint8_t y, char * s)
{

	while(*s) // wykonuj dopóki znak wskazywany przez s jest ró¿ny od zera
	{
    lcdCharBlk36(x,y,*s); // zapis znaku
	set_cursor(x+=(*(CalBlk36_width + (*s++ - 32))) + 2,y); //przesuñ kursor o szerkokoæ znaku + 2pixele
	}

}
/*--------------------------------------------------------------------------------------------------------------------------------*/

const unsigned char AGH_LOGO[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3C, 0xF2, 0x8C, 0x7A, 0xF4, 0x8C,
0x78, 0xF0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF,
0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF,
0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF,
0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF,
0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x07, 0x1F, 0x38, 0x67, 0x5F, 0x30, 0x4F, 0x3F, 0x60, 0x00, 0x00, 0x03, 0x03, 0x00, 0x03, 0x03,
0x00, 0x03, 0x03, 0x00, 0x40, 0x38, 0x5F, 0x23, 0x5C, 0x2F, 0x33, 0x1C, 0x0F, 0x03, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xA0, 0xE0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x60, 0x60,
0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0xE0, 0xE0, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
0x7C, 0x0F, 0x09, 0x09, 0x0F, 0x7F, 0x78, 0x40, 0x00, 0x00, 0x0F, 0x3F, 0x3F, 0x60, 0x60, 0x42,
0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x7F, 0x7F, 0x06, 0x06, 0x06, 0x7F, 0x7F, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


